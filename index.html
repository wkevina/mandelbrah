<!DOCTYPE html>
<html>

<head>
		<meta name=viewport content="width=device-width, initial-scale=1">

		<style>
				body,
				html {
						height: 100%;
						margin: 0;
						font-family: helvetica, tahoma, sans-serif;
				}

				#canvas {
						position: absolute;
						width: 100%;
						height: 100%;
				}

				.absolute {
						position: absolute;
						padding: 0em 1em;
				}

				#stats {
						color: #ddd;
				}
		</style>

</head>

<body>
		<canvas id="canvas"></canvas>

		<script type="text/javascript">
				'use strict';

				/* jshint browser: true */

				var RESTRICT = false;
				// IMPORTANT!!!!!
				if (navigator.userAgent.match(/(iPod|iPhone|iPad)/) && navigator.userAgent.match(/AppleWebKit/)) {
					//RESTRICT = true;
				}

				var scale = 0;
				var limits = {};
				limits.x = 0;
				limits.y = 0;

				var canvas = document.getElementById('canvas');
				var ctx = canvas.getContext('2d');


				function throttle(callback, delay) {
					var timerId;
					return function() {
						if (timerId !== null) {
							window.clearTimeout(timerId);
							console.log("Clearing timer!");
						}
						timerId = window.setTimeout(callback, delay);
						console.log("Setting timer");
					}
				}

				window.addEventListener("resize", throttle(draw, 100));

				function draw() {

					var oldw = canvas.clientWidth,
						oldh = canvas.clientHeight;

					var aspect = oldh / oldw;


					if (RESTRICT) { // we need to keep it under 5 MP

						/*var bytes = oldw * oldh * window.devicePixelRatio * window.devicePixelRatio;

						if (bytes >= 5000000) {
							// recalculate dimensions
							var newy = Math.floor(aspect * 4999999); // x*y = m ; (y/x)x*y = m*(y/x)
							var newx = Math.floor(4999999 / newy);

							canvas.width = limits.x = newx;
							canvas.height = limits.y = newy;
						} else {
							canvas.width = limits.x = oldw * window.devicePixelRatio;
							canvas.height = limits.y = oldh * window.devicePixelRatio;
						}*/
						canvas.width = limits.x = oldw;
						canvas.height = limits.y = oldh;

					} else {
						canvas.width = limits.x = oldw * window.devicePixelRatio;
						canvas.height = limits.y = oldh * window.devicePixelRatio;
					}


					// canvas is now configured

					// must find a 4 x 3 area that fits on canvas

					if (aspect < 3 / 4) {
						// wider than tall
						// height will be limiting dimension
						scale = 3 / limits.y;

					} else {
						scale = 4 / limits.x;
					}

					console.log([scale * canvas.width, scale * canvas.height]);
					mandelbrah();

					var stats = '<p>' + (canvas.width * canvas.height).toLocaleString() + ' MP</p>';
					stats += '<p>' + canvas.width + 'x' + canvas.height + ' px</p>';

					document.getElementById('stats').innerHTML = stats;
				}

				window.dispatchEvent(new UIEvent("resize"));

				function clear() {
					ctx.fillStyle = "rgb(255,255,255)";
					ctx.fillRect(0, 0, limits.x, limits.y);
				}

				function mandelbrah() {
					//clear();

					var data = ctx.createImageData(canvas.width, canvas.height);

					for (var x = 0; x < limits.x; ++x) {
						for (var y = 0; y < limits.y; ++y) {
							drawPoint(x, y, data, 60);
						}
					}
					ctx.putImageData(data, 0, 0);
				}

				function drawPoint(x, y, data, maxiter) {
					// z^2 = (x^2 - y^2, 2xy)
					// abs = sqrt(x^2 + y^2)

					var coord = {
						x: x,
						y: y
					};

					var p = canvasPointToSet(coord);
					x = p.x;
					y = p.y;

					var z = {
						x: 0,
						y: 0
					};

					var mag2 = 0;
					var temp;
					var count = 0;

					var x2 = 0;
					var y2 = 0;

					while (mag2 <= 4 && count < maxiter) {
						++count;

						x2 = z.x * z.x;
						y2 = z.y * z.y;

						temp = {
							x: x2 - y2 + x,
							y: 2 * z.x * z.y + y
						};
						z = temp;
						mag2 = x2 + y2;
					}

					var index = (data.width * coord.y + coord.x) * 4;

					if (mag2 < 4) {
						//ctx.fillStyle = "rgb(0,0,0)";
						//ctx.fillRect(coord.x, coord.y, 1, 1);
						data.data[index] = 255;
						data.data[index + 1] = 255;
						data.data[index + 2] = 255;
						data.data[index + 3] = 255;

					} else {
						//var h = Math.floor(count * 360 / 101);
						//ctx.fillStyle = "hsl(" + [h, '100%', count + '%'].join(',') + ')';
						//ctx.fillRect(coord.x, coord.y, 1, 1);

						var value = Math.log(count);
						var valueScale = Math.log(maxiter);
						var ratio = value / valueScale
						var c = hslToRgb(ratio * 0.1 + 0.9, ratio, count / maxiter);

						data.data[index] = c[0];
						data.data[index + 1] = c[1];
						data.data[index + 2] = c[2];
						data.data[index + 3] = 255;
					}

					// (x - y)^2 + (x + y)^2
				}

				function canvasPointToSet(p) {
					var x = p.x * scale - limits.x * scale * 2 / 3;
					var y = p.y * scale - limits.y * scale * 0.5;
					return {
						x: x,
						y: y
					};
				}

				/**
				 * Converts an HSL color value to RGB. Conversion formula
				 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
				 * Assumes h, s, and l are contained in the set [0, 1] and
				 * returns r, g, and b in the set [0, 255].
				 *
				 * @param   Number  h       The hue
				 * @param   Number  s       The saturation
				 * @param   Number  l       The lightness
				 * @return  Array           The RGB representation
				 */
				function hslToRgb(h, s, l) {
					var r, g, b;

					if (s == 0) {
						r = g = b = l; // achromatic
					} else {
						var hue2rgb = function hue2rgb(p, q, t) {
							if (t < 0) t += 1;
							if (t > 1) t -= 1;
							if (t < 1 / 6) return p + (q - p) * 6 * t;
							if (t < 1 / 2) return q;
							if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
							return p;
						}

						var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
						var p = 2 * l - q;
						r = hue2rgb(p, q, h + 1 / 3);
						g = hue2rgb(p, q, h);
						b = hue2rgb(p, q, h - 1 / 3);
					}

					return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
				}
		</script>

		<div class="absolute">
				<h4 id="stats"></h4>
		</div>


</body>

</html>

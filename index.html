<!DOCTYPE html>
<html>

<head>
		<style>
				body,
				html {
						height: 100%;
						margin: 0;
				}

				#canvas {
						position: absolute;
						width: 100%;
						height: 100%;
				}
		</style>
</head>

<body>
		<canvas id="canvas"></canvas>

		<script type="text/javascript">
				'use strict';

				var scale = 0;
				var limits = {};
				limits.x = 0;
				limits.y = 0;

				var canvas = document.getElementById('canvas');
				var ctx = canvas.getContext('2d');


				function throttle(callback, delay) {
					var timerId;
					return function() {
						if (timerId !== null) {
							window.clearTimeout(timerId);
							console.log("Clearing timer!");
						}
						timerId = window.setTimeout(callback, delay);
						console.log("Setting timer");
					}
				}

				window.addEventListener("resize", throttle(draw, 100));

				function draw() {

					var oldw = canvas.clientWidth,
						oldh = canvas.clientHeight;

					canvas.width = limits.x = oldw * window.devicePixelRatio;
					canvas.height = limits.y = oldh * window.devicePixelRatio;


					// canvas is now configured

					var aspect = canvas.height / canvas.width;

					// must find a 4 x 3 area that fits on canvas

					if (aspect < 3 / 4) {
						// wider than tall
						// height will be limiting dimension
						scale = 3 / limits.y;

					} else {
						scale = 4 / limits.x;
					}

					console.log([scale * canvas.width, scale * canvas.height]);
					mandelbrah();
				}

				window.dispatchEvent(new UIEvent("resize"));

				function clear() {
					ctx.fillStyle = "rgb(255,255,255)";
					ctx.fillRect(0, 0, limits.x, limits.y);
				}

				function mandelbrah() {
					//clear();

					var data = ctx.createImageData(canvas.width, canvas.height);

					for (var x = 0; x < limits.x; ++x) {
						for (var y = 0; y < limits.y; ++y) {
							drawPoint(x, y, data);
						}
					}
					ctx.putImageData(data, 0, 0);
				}

				function drawPoint(x, y, data) {
					// z^2 = (x^2 - y^2, 2xy)
					// abs = sqrt(x^2 + y^2)

					var coord = {
						x: x,
						y: y
					};

					var p = canvasPointToSet(coord);
					x = p.x;
					y = p.y;

					var z = {
						x: 0,
						y: 0
					};

					var mag = 0;
					var temp;
					var count = 0;

					while (mag < 2 && count < 99) {
						++count;
						temp = {
							x: z.x * z.x - z.y * z.y + x,
							y: 2 * z.x * z.y + y
						};
						z = temp;
						mag = Math.sqrt(z.x * z.x + z.y * z.y);
					}

					var index = data.width * coord.y*4 + coord.x*4;

					if (mag < 2) {
						//ctx.fillStyle = "rgb(0,0,0)";
						//ctx.fillRect(coord.x, coord.y, 1, 1);
						data.data[index] = 0;
						data.data[index + 1] = 0;
						data.data[index + 2] = 0;
						data.data[index + 3] = 255;

					} else {
						//var h = Math.floor(count * 360 / 101);
						//ctx.fillStyle = "hsl(" + [h, '100%', count + '%'].join(',') + ')';
						//ctx.fillRect(coord.x, coord.y, 1, 1);

						var value = count/100;
						var c = hslToRgb(value, 1, value);

						data.data[index] = c[0];
						data.data[index + 1] = c[1];
						data.data[index + 2] = c[2];
						data.data[index + 3] = 255;
					}

					// (x - y)^2 + (x + y)^2
				}

				function canvasPointToSet(p) {
					var x = p.x * scale - limits.x * scale * 2/3;
					var y = p.y * scale - limits.y * scale * 0.5;
					return {
						x: x,
						y: y
					};
				}

				/**
				 * Converts an HSL color value to RGB. Conversion formula
				 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
				 * Assumes h, s, and l are contained in the set [0, 1] and
				 * returns r, g, and b in the set [0, 255].
				 *
				 * @param   Number  h       The hue
				 * @param   Number  s       The saturation
				 * @param   Number  l       The lightness
				 * @return  Array           The RGB representation
				 */
				function hslToRgb(h, s, l) {
					var r, g, b;

					if (s == 0) {
						r = g = b = l; // achromatic
					} else {
						var hue2rgb = function hue2rgb(p, q, t) {
							if (t < 0) t += 1;
							if (t > 1) t -= 1;
							if (t < 1 / 6) return p + (q - p) * 6 * t;
							if (t < 1 / 2) return q;
							if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
							return p;
						}

						var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
						var p = 2 * l - q;
						r = hue2rgb(p, q, h + 1 / 3);
						g = hue2rgb(p, q, h);
						b = hue2rgb(p, q, h - 1 / 3);
					}

					return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
				}
		</script>


</body>

</html>
